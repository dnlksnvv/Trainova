import asyncio
import logging
from datetime import datetime, timezone
from typing import List, Optional, Dict, Any
import asyncpg
import json
from collections import defaultdict
from decimal import Decimal
from llm_analyzer import analyze_user_data_direct

logger = logging.getLogger(__name__)


class DecimalEncoder(json.JSONEncoder):
    def default(self, o):
        if isinstance(o, Decimal):
            return float(o)
        return super(DecimalEncoder, self).default(o)


class MotivationWorker:
    def __init__(self, db_pool: asyncpg.Pool, check_interval: int = 10):
        self.db_pool = db_pool
        self.running = False
        self.check_interval = check_interval  # –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ—á–µ—Ä–µ–¥—å –∫–∞–∂–¥—ã–µ N —Å–µ–∫—É–Ω–¥
        self.stuck_task_timeout = 5  # –ó–∞–¥–∞—á–∏ —Å—Ç–∞—Ä—à–µ 5 –º–∏–Ω—É—Ç —Å—á–∏—Ç–∞—é—Ç—Å—è –∑–∞–≤–∏—Å—à–∏–º–∏
        self.recent_stuck_timeout = 2  # –ù–µ–¥–∞–≤–Ω–æ –∑–∞–≤–∏—Å—à–∏–µ - —Å—Ç–∞—Ä—à–µ 2 –º–∏–Ω—É—Ç

    async def start(self):
        """–ó–∞–ø—É—Å–∫ –≤–æ—Ä–∫–µ—Ä–∞"""
        self.running = True
        current_time_utc = datetime.now(timezone.utc)
        logger.info(f"üöÄ Background Worker –∑–∞–ø—É—â–µ–Ω –≤ UTC: {current_time_utc}")
        
        # –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∑–∞–≤–∏—Å—à–∏–µ –∑–∞–¥–∞—á–∏ –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ
        await self.recover_stuck_tasks()
        
        while self.running:
            try:
                await self.process_pending_tasks()
                await asyncio.sleep(self.check_interval)
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –≤ background worker: {str(e)}")
                await asyncio.sleep(self.check_interval)

    async def stop(self):
        """–û—Å—Ç–∞–Ω–æ–≤–∫–∞ –≤–æ—Ä–∫–µ—Ä–∞"""
        self.running = False
        current_time_utc = datetime.now(timezone.utc)
        logger.info(f"üõë Background Worker –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –≤ UTC: {current_time_utc}")

    async def recover_stuck_tasks(self):
        """–í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ –∑–∞–≤–∏—Å—à–∏—Ö –∑–∞–¥–∞—á –ø–æ—Å–ª–µ –ø–∞–¥–µ–Ω–∏—è —Å–µ—Ä–≤–∏—Å–∞"""
        try:
            current_time_utc = datetime.now(timezone.utc)
            logger.info(f"üîß –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–≤–∏—Å—à–∏—Ö –∑–∞–¥–∞—á –≤ UTC: {current_time_utc}")
            
            async with self.db_pool.acquire() as connection:
                # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º —Å–ø–∏—Å–∫–∏ –¥–ª—è –ø–æ–¥—Å—á–µ—Ç–∞
                stuck_tasks = []
                deepfit_error_tasks = []
                failed_tasks = []
                failed_no_completion_tasks = []
                
                # 1. –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∑–∞–≤–∏—Å—à–∏–µ –∑–∞–¥–∞—á–∏ in_progress (—Å—Ç–∞—Ä—à–µ 5 –º–∏–Ω—É—Ç)
                query = """
                    SELECT neuro_generation_queue_id, daily_motivation_uuid, datetime_started
                    FROM neuro_generation_queue
                    WHERE status = 'in_progress' 
                    AND ($1::TIMESTAMPTZ - datetime_started) > INTERVAL '%s minutes'
                """ % self.stuck_task_timeout
                stuck_tasks = await connection.fetch(query, current_time_utc)
                
                if stuck_tasks:
                    logger.info(f"üîß –ù–∞–π–¥–µ–Ω–æ {len(stuck_tasks)} –∑–∞–≤–∏—Å—à–∏—Ö –∑–∞–¥–∞—á –¥–ª—è –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è")
                    
                    for task in stuck_tasks:
                        task_id = task['neuro_generation_queue_id']
                        motivation_uuid = task['daily_motivation_uuid']
                        started_time = task['datetime_started']
                        
                        # –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—Ç–∞—Ç—É—Å –∑–∞–¥–∞—á–∏ –æ–±—Ä–∞—Ç–Ω–æ –≤ 'new'
                        await connection.execute("""
                            UPDATE neuro_generation_queue
                            SET status = $1::VARCHAR,
                                datetime_started = NULL
                            WHERE neuro_generation_queue_id = $2
                        """, 'new', task_id)
                        
                        # –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—Ç–∞—Ç—É—Å –º–æ—Ç–∏–≤–∞—Ü–∏–∏ –æ–±—Ä–∞—Ç–Ω–æ –≤ 'new' —Å UTC timestamp
                        await connection.execute("""
                            UPDATE daily_motivation
                            SET status = $1::VARCHAR,
                                updated_at = $2::TIMESTAMPTZ
                            WHERE daily_motivation_uuid = $3::UUID
                        """, 'new', current_time_utc, motivation_uuid)
                        
                        logger.info(f"üîÑ –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞ –∑–∞–≤–∏—Å—à–∞—è –∑–∞–¥–∞—á–∞ {task_id} (–∑–∞–≤–∏—Å–ª–∞ —Å {started_time} UTC)")
                
                # 2. –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∑–∞–¥–∞—á–∏ —Å –æ—à–∏–±–∫–æ–π –≤–∞–ª–∏–¥–∞—Ü–∏–∏ deepfit-error (—Å—Ç–∞—Ä—à–µ 10 –º–∏–Ω—É—Ç)
                deepfit_error_query = """
                    SELECT neuro_generation_queue_id, daily_motivation_uuid, datetime_completed
                    FROM neuro_generation_queue
                    WHERE status = 'deepfit-error' 
                    AND ($1::TIMESTAMPTZ - datetime_completed) > INTERVAL '10 minutes'
                """
                deepfit_error_tasks = await connection.fetch(deepfit_error_query, current_time_utc)
                
                if deepfit_error_tasks:
                    logger.info(f"üîß –ù–∞–π–¥–µ–Ω–æ {len(deepfit_error_tasks)} –∑–∞–¥–∞—á deepfit-error –¥–ª—è –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏")
                    
                    for task in deepfit_error_tasks:
                        task_id = task['neuro_generation_queue_id']
                        motivation_uuid = task['daily_motivation_uuid']
                        error_time = task['datetime_completed']
                        
                        # –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—Ç–∞—Ç—É—Å –∑–∞–¥–∞—á–∏ –æ–±—Ä–∞—Ç–Ω–æ –≤ 'new'
                        await connection.execute("""
                            UPDATE neuro_generation_queue
                            SET status = $1::VARCHAR,
                                datetime_started = NULL,
                                datetime_completed = NULL
                            WHERE neuro_generation_queue_id = $2
                        """, 'new', task_id)
                        
                        # –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—Ç–∞—Ç—É—Å –º–æ—Ç–∏–≤–∞—Ü–∏–∏ –æ–±—Ä–∞—Ç–Ω–æ –≤ 'new'
                        await connection.execute("""
                            UPDATE daily_motivation
                            SET status = $1::VARCHAR,
                                updated_at = $2::TIMESTAMPTZ
                            WHERE daily_motivation_uuid = $3::UUID
                        """, 'new', current_time_utc, motivation_uuid)
                        
                        logger.info(f"üîÑ –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞ –∑–∞–¥–∞—á–∞ deepfit-error {task_id} (–æ—à–∏–±–∫–∞ —Å {error_time} UTC)")
                
                # 3. –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∑–∞–¥–∞—á–∏ —Å –æ—à–∏–±–∫–æ–π failed (—Å—Ç–∞—Ä—à–µ 2 –º–∏–Ω—É—Ç)
                failed_query = """
                    SELECT neuro_generation_queue_id, daily_motivation_uuid, datetime_completed
                    FROM neuro_generation_queue
                    WHERE status = 'failed' 
                    AND datetime_completed IS NOT NULL
                    AND ($1::TIMESTAMPTZ - datetime_completed) > INTERVAL '2 minutes'
                """
                failed_tasks = await connection.fetch(failed_query, current_time_utc)
                
                if failed_tasks:
                    logger.info(f"üîß –ù–∞–π–¥–µ–Ω–æ {len(failed_tasks)} –∑–∞–¥–∞—á failed –¥–ª—è –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏")
                    
                    for task in failed_tasks:
                        task_id = task['neuro_generation_queue_id']
                        motivation_uuid = task['daily_motivation_uuid']
                        error_time = task['datetime_completed']
                        
                        # –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—Ç–∞—Ç—É—Å –∑–∞–¥–∞—á–∏ –æ–±—Ä–∞—Ç–Ω–æ –≤ 'new'
                        await connection.execute("""
                            UPDATE neuro_generation_queue
                            SET status = $1::VARCHAR,
                                datetime_started = NULL,
                                datetime_completed = NULL
                            WHERE neuro_generation_queue_id = $2
                        """, 'new', task_id)
                        
                        # –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—Ç–∞—Ç—É—Å –º–æ—Ç–∏–≤–∞—Ü–∏–∏ –æ–±—Ä–∞—Ç–Ω–æ –≤ 'new'
                        await connection.execute("""
                            UPDATE daily_motivation
                            SET status = $1::VARCHAR,
                                updated_at = $2::TIMESTAMPTZ
                            WHERE daily_motivation_uuid = $3::UUID
                        """, 'new', current_time_utc, motivation_uuid)
                        
                        logger.info(f"üîÑ –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞ –∑–∞–¥–∞—á–∞ failed {task_id} (–æ—à–∏–±–∫–∞ —Å {error_time} UTC)")
                
                # 4. –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∑–∞–¥–∞—á–∏ failed –±–µ–∑ datetime_completed (—Å—Ç–∞—Ä—à–µ 2 –º–∏–Ω—É—Ç –æ—Ç —Å–æ–∑–¥–∞–Ω–∏—è)
                failed_no_completion_query = """
                    SELECT neuro_generation_queue_id, daily_motivation_uuid, datetime_created
                    FROM neuro_generation_queue
                    WHERE status = 'failed' 
                    AND datetime_completed IS NULL
                    AND ($1::TIMESTAMPTZ - datetime_created) > INTERVAL '2 minutes'
                """
                failed_no_completion_tasks = await connection.fetch(failed_no_completion_query, current_time_utc)
                
                if failed_no_completion_tasks:
                    logger.info(f"üîß –ù–∞–π–¥–µ–Ω–æ {len(failed_no_completion_tasks)} –∑–∞–¥–∞—á failed –±–µ–∑ datetime_completed –¥–ª—è –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏")
                    
                    for task in failed_no_completion_tasks:
                        task_id = task['neuro_generation_queue_id']
                        motivation_uuid = task['daily_motivation_uuid']
                        created_time = task['datetime_created']
                        
                        # –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—Ç–∞—Ç—É—Å –∑–∞–¥–∞—á–∏ –æ–±—Ä–∞—Ç–Ω–æ –≤ 'new'
                        await connection.execute("""
                            UPDATE neuro_generation_queue
                            SET status = $1::VARCHAR,
                                datetime_started = NULL,
                                datetime_completed = NULL
                            WHERE neuro_generation_queue_id = $2
                        """, 'new', task_id)
                        
                        # –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—Ç–∞—Ç—É—Å –º–æ—Ç–∏–≤–∞—Ü–∏–∏ –æ–±—Ä–∞—Ç–Ω–æ –≤ 'new'
                        await connection.execute("""
                            UPDATE daily_motivation
                            SET status = $1::VARCHAR,
                                updated_at = $2::TIMESTAMPTZ
                            WHERE daily_motivation_uuid = $3::UUID
                        """, 'new', current_time_utc, motivation_uuid)
                        
                        logger.info(f"üîÑ –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞ –∑–∞–¥–∞—á–∞ failed –±–µ–∑ completion {task_id} (—Å–æ–∑–¥–∞–Ω–∞ {created_time} UTC)")
                
                total_recovered = len(stuck_tasks) + len(deepfit_error_tasks) + len(failed_tasks) + len(failed_no_completion_tasks)
                if total_recovered > 0:
                    logger.info(f"‚úÖ –í—Å–µ–≥–æ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ {total_recovered} –∑–∞–¥–∞—á")
                else:
                    logger.info("‚úÖ –ó–∞–¥–∞—á –¥–ª—è –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–æ")
                    
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–∏ –∑–∞–≤–∏—Å—à–∏—Ö –∑–∞–¥–∞—á: {str(e)}")

    async def process_pending_tasks(self):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–¥–∞—á –≤ –æ—á–µ—Ä–µ–¥–∏"""
        async with self.db_pool.acquire() as connection:
            # –ü–æ–ª—É—á–∞–µ–º –∑–∞–¥–∞—á–∏ —Å–æ —Å—Ç–∞—Ç—É—Å–æ–º 'new' + –ø—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞ –∑–∞–≤–∏—Å—à–∏–µ in_progress
            pending_tasks = await self.get_pending_tasks(connection)
            
            if not pending_tasks:
                # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ –ø—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞ —Å–≤–µ–∂–∏–µ –∑–∞–≤–∏—Å—à–∏–µ –∑–∞–¥–∞—á–∏ (–∫–∞–∂–¥—É—é –∏—Ç–µ—Ä–∞—Ü–∏—é)
                await self.check_recent_stuck_tasks(connection)
                return  # –ù–µ—Ç –∑–∞–¥–∞—á –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏
            
            logger.info(f"üìã –ù–∞–π–¥–µ–Ω–æ {len(pending_tasks)} –∑–∞–¥–∞—á –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏")
            
            for task in pending_tasks:
                try:
                    await self.process_single_task(connection, task)
                except Exception as e:
                    logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∑–∞–¥–∞—á–∏ {task['neuro_generation_queue_id']}: {str(e)}")
                    # –ü—Ä–∏ –æ—à–∏–±–∫–µ —Å—Ç–∞–≤–∏–º —Å—Ç–∞—Ç—É—Å 'failed'
                    await self.update_task_status(
                        connection, 
                        task['neuro_generation_queue_id'], 
                        'failed'
                    )

    async def get_pending_tasks(self, connection: asyncpg.Connection) -> List[dict]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –∑–∞–¥–∞—á —Å–æ —Å—Ç–∞—Ç—É—Å–æ–º 'new' –≤ –ø–æ—Ä—è–¥–∫–µ –ø–æ—Å—Ç—É–ø–ª–µ–Ω–∏—è (FIFO)"""
        query = """
            SELECT neuro_generation_queue_id, daily_motivation_uuid, status, datetime_created
            FROM neuro_generation_queue
            WHERE status = 'new'
            ORDER BY datetime_created ASC, neuro_generation_queue_id ASC
            LIMIT 5
        """
        rows = await connection.fetch(query)
        
        # –õ–æ–≥–∏—Ä—É–µ–º –ø–æ—Ä—è–¥–æ–∫ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
        if rows:
            task_ids = [row['neuro_generation_queue_id'] for row in rows]
            logger.info(f"üìã –ü–æ—Ä—è–¥–æ–∫ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∑–∞–¥–∞—á: {task_ids}")
        
        return [dict(row) for row in rows]

    async def process_single_task(self, connection: asyncpg.Connection, task: dict):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –æ–¥–Ω–æ–π –∑–∞–¥–∞—á–∏"""
        task_id = task['neuro_generation_queue_id']
        motivation_uuid = task['daily_motivation_uuid']
        created_time = task['datetime_created']
        current_time_utc = datetime.now(timezone.utc)
        
        logger.info(f"üîÑ –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∑–∞–¥–∞—á—É ID={task_id} (—Å–æ–∑–¥–∞–Ω–∞: {created_time} UTC) –¥–ª—è –º–æ—Ç–∏–≤–∞—Ü–∏–∏ {motivation_uuid}")
        
        # 1. –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –∑–∞–¥–∞—á–∏ –Ω–∞ 'in_progress'
        await self.update_task_status(connection, task_id, 'in_progress')
        
        # 2. –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏ –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º –º–æ—Ç–∏–≤–∞—Ü–∏–æ–Ω–Ω—ã–π –∫–æ–Ω—Ç–µ–Ω—Ç
        motivation_data = await self.generate_motivation_content(connection, motivation_uuid)
        
        # 3. –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Å—Ç–∞—Ç—É—Å–∞
        result_status = motivation_data.get("status", "success")
        
        if result_status == "success":
            # –£—Å–ø–µ—à–Ω—ã–π –∞–Ω–∞–ª–∏–∑ - –∑–∞–ø–∏—Å—ã–≤–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –∏ —Å—Ç–∞–≤–∏–º completed
            await self.update_daily_motivation(
                connection, 
                motivation_uuid, 
                motivation_data['message'],
                motivation_data['fact'],
                motivation_data['advice'],
                'completed'
            )
            await self.update_task_status(connection, task_id, 'completed')
            
            end_time_utc = datetime.now(timezone.utc)
            processing_time = (end_time_utc - current_time_utc).total_seconds()
            logger.info(f"‚úÖ –ó–∞–¥–∞—á–∞ ID={task_id} —É—Å–ø–µ—à–Ω–æ –≤—ã–ø–æ–ª–Ω–µ–Ω–∞ –∑–∞ {processing_time:.2f} —Å–µ–∫ (UTC: {end_time_utc})")
            
        elif result_status == "validation_error":
            # –û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ - —Å—Ç–∞–≤–∏–º deepfit-error —Å—Ç–∞—Ç—É—Å –¥–ª—è –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏
            await self.update_daily_motivation(
                connection, 
                motivation_uuid, 
                motivation_data['message'],
                motivation_data['fact'],
                motivation_data['advice'],
                'deepfit-error'
            )
            await self.update_task_status(connection, task_id, 'deepfit-error')
            
            logger.warning(f"‚ö†Ô∏è –ó–∞–¥–∞—á–∞ ID={task_id} - –æ—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ LLM, —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω —Å—Ç–∞—Ç—É—Å deepfit-error")
            
        else:
            # –î—Ä—É–≥–∏–µ –æ—à–∏–±–∫–∏ (llm_error, data_error) - —Å—Ç–∞–≤–∏–º failed
            await self.update_daily_motivation(
                connection, 
                motivation_uuid, 
                motivation_data['message'],
                motivation_data['fact'],
                motivation_data['advice'],
                'failed'
            )
            await self.update_task_status(connection, task_id, 'failed')
            
            logger.error(f"‚ùå –ó–∞–¥–∞—á–∞ ID={task_id} –∑–∞–≤–µ—Ä—à–µ–Ω–∞ —Å –æ—à–∏–±–∫–æ–π: {result_status}")

    async def update_task_status(self, connection: asyncpg.Connection, task_id: int, status: str):
        """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ –∑–∞–¥–∞—á–∏ –≤ –æ—á–µ—Ä–µ–¥–∏ —Å UTC timestamps"""
        current_time_utc = datetime.now(timezone.utc)
        
        query = """
            UPDATE neuro_generation_queue
            SET status = $1::VARCHAR,
                datetime_started = CASE WHEN $1::VARCHAR = 'in_progress' THEN $2::TIMESTAMPTZ ELSE datetime_started END,
                datetime_completed = CASE WHEN $1::VARCHAR IN ('completed', 'failed') THEN $2::TIMESTAMPTZ ELSE datetime_completed END
            WHERE neuro_generation_queue_id = $3
        """
        await connection.execute(query, status, current_time_utc, task_id)

    async def update_daily_motivation(self, connection: asyncpg.Connection, 
                                     motivation_uuid: str, message: str, fact: str, advice: str, status: str):
        """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –º–æ—Ç–∏–≤–∞—Ü–∏–æ–Ω–Ω–æ–π –∑–∞–ø–∏—Å–∏ —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–º –∏ UTC timestamp"""
        current_time_utc = datetime.now(timezone.utc)
        
        query = """
            UPDATE daily_motivation
            SET motivation_message = $1::TEXT,
                fact = $2::TEXT,
                advice = $3::TEXT,
                status = $4::VARCHAR,
                updated_at = $5::TIMESTAMPTZ
            WHERE daily_motivation_uuid = $6::UUID
        """
        await connection.execute(query, message, fact, advice, status, current_time_utc, motivation_uuid)

    async def generate_motivation_content(self, connection: asyncpg.Connection, motivation_uuid: str) -> dict:
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –º–æ—Ç–∏–≤–∞—Ü–∏–æ–Ω–Ω–æ–≥–æ –∫–æ–Ω—Ç–µ–Ω—Ç–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ä–µ–∞–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        try:
            # 1. –ü–æ–ª—É—á–∞–µ–º user_id, date_start, date_ended –∏–∑ daily_motivation
            motivation_query = """
                SELECT user_id, date_start, date_ended
                FROM daily_motivation
                WHERE daily_motivation_uuid = $1::UUID
            """
            motivation_row = await connection.fetchrow(motivation_query, motivation_uuid)
            
            if not motivation_row:
                raise Exception(f"–ù–µ –Ω–∞–π–¥–µ–Ω–∞ –º–æ—Ç–∏–≤–∞—Ü–∏—è —Å UUID: {motivation_uuid}")
            
            user_id = motivation_row['user_id']
            date_start = motivation_row['date_start']
            date_ended = motivation_row['date_ended']
            
            # 2. –ü–æ–ª—É—á–∞–µ–º —É—Ä–æ–≤–µ–Ω—å –∂—ë—Å—Ç–∫–æ—Å—Ç–∏ –æ—Ç–≤–µ—Ç–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            user_level_query = """
                SELECT response_level_id
                FROM user_response_levels
                WHERE user_id = $1
            """
            user_level_row = await connection.fetchrow(user_level_query, user_id)
            response_level_id = user_level_row['response_level_id'] if user_level_row else 1  # –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é –ª–æ—è–ª—å–Ω—ã–π
            
            logger.info(f"üéØ –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –º–æ—Ç–∏–≤–∞—Ü–∏–∏ –¥–ª—è user_id={user_id} —Å —É—Ä–æ–≤–Ω–µ–º –∂—ë—Å—Ç–∫–æ—Å—Ç–∏: {response_level_id}")
            
            # 3. –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –≤–µ—Å–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∑–∞ –ø–µ—Ä–∏–æ–¥
            weights_query = """
                SELECT record_date, weight
                FROM user_weights
                WHERE user_id = $1 
                AND record_date >= $2 
                AND record_date <= $3
                ORDER BY record_date ASC
            """
            weights_data = await connection.fetch(weights_query, user_id, date_start, date_ended)
            
            # 4. –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∑–∞ –ø–µ—Ä–∏–æ–¥
            activities_query = """
                SELECT record_date, workout_count
                FROM user_activities
                WHERE user_id = $1 
                AND record_date >= $2 
                AND record_date <= $3
                ORDER BY record_date ASC
            """
            activities_data = await connection.fetch(activities_query, user_id, date_start, date_ended)
            
            # 5. –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –æ –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω—ã—Ö —É–ø—Ä–∞–∂–Ω–µ–Ω–∏—è—Ö –∑–∞ –ø–µ—Ä–∏–æ–¥
            exercises_query = """
                SELECT 
                    ues.exercise_session_uuid,
                    ues.workout_session_uuid,
                    ues.exercise_uuid,
                    ues.datetime_start,
                    ues.datetime_end,
                    ues.status,
                    DATE(ues.datetime_start AT TIME ZONE 'UTC') as session_date
                FROM user_exercise_sessions ues
                WHERE ues.user_id = $1 
                AND ues.datetime_start IS NOT NULL
                AND DATE(ues.datetime_start AT TIME ZONE 'UTC') >= $2
                AND DATE(ues.datetime_start AT TIME ZONE 'UTC') <= $3
                ORDER BY ues.datetime_start ASC
            """
            exercises_sessions_data = await connection.fetch(exercises_query, user_id, date_start, date_ended)
            
            # 6. –î–ª—è –∫–∞–∂–¥–æ–≥–æ exercise_uuid –ø–æ–ª—É—á–∞–µ–º –ø–æ–¥—Ä–æ–±–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é
            exercise_details = []
            if exercises_sessions_data:
                for session in exercises_sessions_data:
                    exercise_uuid = session['exercise_uuid']
                    workout_session_uuid = session['workout_session_uuid']
                    
                    # –ü–æ–ª—É—á–∞–µ–º workout_uuid –∏–∑ user_workout_sessions
                    workout_session_query = """
                        SELECT workout_uuid
                        FROM user_workout_sessions
                        WHERE workout_session_uuid = $1::UUID
                        LIMIT 1
                    """
                    workout_session_row = await connection.fetchrow(workout_session_query, workout_session_uuid)
                    workout_uuid = workout_session_row['workout_uuid'] if workout_session_row else None
                    
                    # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –∏–∑ app_workout_exercises
                    workout_exercise_query = """
                        SELECT duration, count, exercise_id
                        FROM app_workout_exercises
                        WHERE id = $1::UUID
                        LIMIT 1
                    """
                    workout_exercise_row = await connection.fetchrow(workout_exercise_query, exercise_uuid)
                    
                    if not workout_exercise_row:
                        continue
                    
                    exercise_id = workout_exercise_row['exercise_id'] 
                    
                    # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± —É–ø—Ä–∞–∂–Ω–µ–Ω–∏–∏ –∏–∑ —Ç–∞–±–ª–∏—Ü—ã exercises
                    exercise_info_query = """
                        SELECT muscle_group_id, title
                        FROM exercises
                        WHERE exercise_id = $1::UUID
                    """
                    exercise_info_row = await connection.fetchrow(exercise_info_query, exercise_id)
                    
                    if not exercise_info_row:
                        # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —Ñ–∞–∫—Ç–∏—á–µ—Å–∫–æ–µ –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —É–ø—Ä–∞–∂–Ω–µ–Ω–∏—è
                        actual_duration_seconds = None
                        if session['datetime_start'] and session['datetime_end']:
                            duration_delta = session['datetime_end'] - session['datetime_start']
                            actual_duration_seconds = int(duration_delta.total_seconds())
                        
                        exercise_type_id = 2 if workout_exercise_row['count'] else 1
                        planned_count = workout_exercise_row['count'] if workout_exercise_row['count'] else "–Ω–µ —É–∫–∞–∑–∞–Ω–æ"
                        
                        exercise_details.append({
                            'exercise_session_uuid': session['exercise_session_uuid'],
                            'workout_session_uuid': session['workout_session_uuid'],
                            'workout_uuid': workout_uuid,
                            'exercise_uuid': session['exercise_uuid'],
                            'exercise_id': exercise_id,
                            'datetime_start': session['datetime_start'],
                            'datetime_end': session['datetime_end'],
                            'status': session['status'],
                            'actual_duration_seconds': actual_duration_seconds,
                            'planned_count': planned_count,
                            'exercise_type_id': exercise_type_id,
                            'exercise_title': f'–£–ø—Ä–∞–∂–Ω–µ–Ω–∏–µ {exercise_id}',
                            'muscle_group_id': None,
                            'muscle_group_name': '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ'
                        })
                        continue
                        
                    muscle_group_id = exercise_info_row['muscle_group_id']
                    
                    # –ü–æ–ª—É—á–∞–µ–º –Ω–∞–∑–≤–∞–Ω–∏–µ –≥—Ä—É–ø–ø—ã –º—ã—à—Ü
                    muscle_group_query = """
                        SELECT name
                        FROM muscle_groups
                        WHERE id = $1
                    """
                    muscle_group_row = await connection.fetchrow(muscle_group_query, muscle_group_id)
                    
                    # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —Ñ–∞–∫—Ç–∏—á–µ—Å–∫–æ–µ –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —É–ø—Ä–∞–∂–Ω–µ–Ω–∏—è
                    actual_duration_seconds = None
                    if session['datetime_start'] and session['datetime_end']:
                        duration_delta = session['datetime_end'] - session['datetime_start']
                        actual_duration_seconds = int(duration_delta.total_seconds())
                    
                    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º ID —Ç–∏–ø–∞ —É–ø—Ä–∞–∂–Ω–µ–Ω–∏—è: 1 - —Å—Ç–∞—Ç–∏—á–µ—Å–∫–æ–µ, 2 - –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–µ
                    exercise_type_id = 2 if workout_exercise_row['count'] else 1
                    planned_count = workout_exercise_row['count'] if workout_exercise_row['count'] else "–Ω–µ —É–∫–∞–∑–∞–Ω–æ"
                    
                    exercise_details.append({
                        'exercise_session_uuid': session['exercise_session_uuid'],
                        'workout_session_uuid': session['workout_session_uuid'],
                        'workout_uuid': workout_uuid,
                        'exercise_uuid': session['exercise_uuid'],
                        'exercise_id': exercise_id,
                        'datetime_start': session['datetime_start'],
                        'datetime_end': session['datetime_end'],
                        'status': session['status'],
                        'actual_duration_seconds': actual_duration_seconds,
                        'planned_count': planned_count,
                        'exercise_type_id': exercise_type_id,
                        'exercise_title': exercise_info_row['title'],
                        'muscle_group_id': muscle_group_id,
                        'muscle_group_name': muscle_group_row['name'] if muscle_group_row else '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ'
                    })
            
            # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∞—Ö
            workout_info = {}
            if exercise_details:
                unique_workout_uuids = list(set(ex['workout_uuid'] for ex in exercise_details if ex['workout_uuid']))
                if unique_workout_uuids:
                    for workout_uuid in unique_workout_uuids:
                        workout_query = """
                            SELECT name, description
                            FROM app_workouts
                            WHERE app_workout_uuid = $1::UUID
                        """
                        workout_row = await connection.fetchrow(workout_query, workout_uuid)
                        if workout_row:
                            workout_info[workout_uuid] = {
                                'name': workout_row['name'],
                                'description': workout_row['description']
                            }
            
            # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è –ø–µ—Ä–µ–¥–∞—á–∏ –≤ LLM
            user_data = self.generate_analysis_data(
                user_id, date_start, date_ended, 
                weights_data, activities_data, 
                exercise_details, workout_info
            )
            
            # –õ–æ–≥–∏—Ä—É–µ–º JSON, –∫–æ—Ç–æ—Ä—ã–π –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è –≤ –Ω–µ–π—Ä–æ—Å–µ—Ç—å
            logger.info(f"üß† JSON –¥–ª—è –Ω–µ–π—Ä–æ—Å–µ—Ç–∏ (user_id={user_id}, —É—Ä–æ–≤–µ–Ω—å={response_level_id}):")
            logger.info(json.dumps(user_data, ensure_ascii=False, indent=2, cls=DecimalEncoder))
            
            # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –¥–∞–Ω–Ω—ã–µ —á–µ—Ä–µ–∑ LLM
            try:
                llm_result = analyze_user_data_direct(user_data, response_level_id)
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤–∞–ª–∏–¥–∞—Ü–∏—é
                if llm_result.get("validation_token") != "deepfit-ok":
                    logger.error("–í–∞–ª–∏–¥–∞—Ü–∏—è LLM –æ—Ç–≤–µ—Ç–∞ –Ω–µ –ø—Ä–æ—à–ª–∞ - –Ω–µ–≤–µ—Ä–Ω—ã–π validation_token")
                    return {
                        "status": "validation_error",
                        "message": "–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏",
                        "fact": "–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏",
                        "advice": "–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏"
                    }
                
                # –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –æ—Ç LLM
                return {
                    "status": "success",
                    "message": llm_result["motivation_message"],
                    "fact": llm_result["fact"],
                    "advice": llm_result["advice"]
                }
                
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—Ä–æ—Å–µ –∫ LLM: {str(e)}")
                return {
                    "status": "llm_error",
                    "message": "–û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞",
                    "fact": "–û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞", 
                    "advice": "–û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞"
                }
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –¥–∞–Ω–Ω—ã—Ö: {str(e)}")
            
            return {
                "status": "data_error",
                "message": "–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –¥–∞–Ω–Ω—ã—Ö",
                "fact": "–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –¥–∞–Ω–Ω—ã—Ö", 
                "advice": "–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –¥–∞–Ω–Ω—ã—Ö"
            }

    async def check_recent_stuck_tasks(self, connection):
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –Ω–µ–¥–∞–≤–Ω–æ –∑–∞–≤–∏—Å—à–∏–µ –∑–∞–¥–∞—á–∏ (timeout 2 –º–∏–Ω—É—Ç—ã)"""
        current_time_utc = datetime.now(timezone.utc)
        
        # –ò—Å–ø—Ä–∞–≤–ª—è–µ–º SQL –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–π —Ä–∞–±–æ—Ç—ã —Å PostgreSQL timestamp with time zone
        query = """
            SELECT neuro_generation_queue_id, daily_motivation_uuid
            FROM neuro_generation_queue
            WHERE status = 'in_progress' 
            AND ($1::TIMESTAMPTZ - datetime_started) > INTERVAL '%s minutes'
            LIMIT 3
        """ % self.recent_stuck_timeout
        
        recent_stuck = await connection.fetch(query, current_time_utc)
        
        if recent_stuck:
            logger.warning(f"‚ö†Ô∏è –ù–∞–π–¥–µ–Ω–æ {len(recent_stuck)} –Ω–µ–¥–∞–≤–Ω–æ –∑–∞–≤–∏—Å—à–∏—Ö –∑–∞–¥–∞—á")
            
            for task in recent_stuck:
                task_id = task['neuro_generation_queue_id'] 
                motivation_uuid = task['daily_motivation_uuid']
                
                # –°–±—Ä–∞—Å—ã–≤–∞–µ–º –≤ 'new'
                await connection.execute("""
                    UPDATE neuro_generation_queue
                    SET status = $1::VARCHAR,
                        datetime_started = NULL
                    WHERE neuro_generation_queue_id = $2
                """, 'new', task_id)
                
                await connection.execute("""
                    UPDATE daily_motivation
                    SET status = $1::VARCHAR,
                        updated_at = $2::TIMESTAMPTZ
                    WHERE daily_motivation_uuid = $3::UUID
                """, 'new', current_time_utc, motivation_uuid)
                
                logger.info(f"üîÑ –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞ –Ω–µ–¥–∞–≤–Ω–æ –∑–∞–≤–∏—Å—à–∞—è –∑–∞–¥–∞—á–∞ {task_id}") 

    def generate_analysis_data(self, user_id: int, date_start: str, date_ended: str, 
                              weights_data: List, activities_data: List, 
                              exercise_details: List, workout_info: Dict) -> Dict:
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö –¥–ª—è LLM —Å –≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫–æ–π –ø–æ –¥–Ω—è–º"""
        
        # –°–æ–∑–¥–∞–µ–º —Å–ª–æ–≤–∞—Ä—å –≤–µ—Å–∞ –ø–æ –¥–Ω—è–º
        weight_by_date = {str(w['record_date']): float(w['weight']) if isinstance(w['weight'], Decimal) else w['weight'] for w in weights_data}
        
        # –°–æ–∑–¥–∞–µ–º —Å–ª–æ–≤–∞—Ä—å –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ –ø–æ –¥–Ω—è–º  
        activity_by_date = {str(a['record_date']): a['workout_count'] for a in activities_data}
        
        # –ì—Ä—É–ø–ø–∏—Ä—É–µ–º —É–ø—Ä–∞–∂–Ω–µ–Ω–∏—è –ø–æ –¥–Ω—è–º –∏ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–æ—á–Ω—ã–º —Å–µ—Å—Å–∏—è–º
        sessions_by_date = defaultdict(lambda: defaultdict(list))
        
        for ex in exercise_details:
            if ex['datetime_start']:
                date = ex['datetime_start'].date().isoformat()
                workout_session_uuid = str(ex['workout_session_uuid']) if ex['workout_session_uuid'] else 'unknown'
                sessions_by_date[date][workout_session_uuid].append(ex)
        
        # –§–æ—Ä–º–∏—Ä—É–µ–º –¥–Ω–∏ —Å —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∞–º–∏
        days = []
        
        for date in sorted(sessions_by_date.keys()):
            day_weight = weight_by_date.get(date)
            sessions = sessions_by_date[date]
            
            workouts = []
            for workout_session_uuid, exercises in sessions.items():
                if not exercises:
                    continue
                    
                # –ë–µ—Ä–µ–º –¥–∞–Ω–Ω—ã–µ –æ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–µ –∏–∑ –ø–µ—Ä–≤–æ–≥–æ —É–ø—Ä–∞–∂–Ω–µ–Ω–∏—è
                first_exercise = exercises[0]
                workout_uuid = first_exercise['workout_uuid']
                
                # –ü–æ–ª—É—á–∞–µ–º –Ω–∞–∑–≤–∞–Ω–∏–µ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∏
                workout_name = "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∞"
                if workout_uuid and workout_uuid in workout_info:
                    workout_name = workout_info[workout_uuid]['name']
                
                # –§–æ—Ä–º–∏—Ä—É–µ–º —Å–ø–∏—Å–æ–∫ —É–ø—Ä–∞–∂–Ω–µ–Ω–∏–π –¥–ª—è —ç—Ç–æ–π —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∏
                exercises_list = []
                for ex in exercises:
                    # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º —É–ø—Ä–∞–∂–Ω–µ–Ω–∏—è –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å—é –±–æ–ª–µ–µ 20 –º–∏–Ω—É—Ç (1200 —Å–µ–∫—É–Ω–¥)
                    if ex['actual_duration_seconds'] is not None and ex['actual_duration_seconds'] > 1200:
                        continue
                        
                    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø —É–ø—Ä–∞–∂–Ω–µ–Ω–∏—è
                    exercise_type = "–î–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–µ" if ex['exercise_type_id'] == 2 else "–°—Ç–∞—Ç–∏—á–µ—Å–∫–æ–µ"
                    
                    exercise_data = {
                        "exercise_name": ex['exercise_title'],
                        "muscle_group_name": ex['muscle_group_name'],
                        "type": exercise_type,
                        "duration_seconds": ex['actual_duration_seconds'],
                        "status": "–∑–∞–≤–µ—Ä—à–µ–Ω–æ" if ex['status'] == 'ended' else ex['status'],
                        "start_time": ex['datetime_start'].isoformat() if ex['datetime_start'] else None,
                        "end_time": ex['datetime_end'].isoformat() if ex['datetime_end'] else None
                    }
                    
                    # –î–æ–±–∞–≤–ª—è–µ–º repetitions —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –±–æ–ª—å—à–µ 0
                    if ex['planned_count'] != "–Ω–µ —É–∫–∞–∑–∞–Ω–æ" and ex['planned_count'] and ex['planned_count'] > 0:
                        exercise_data["repetitions"] = ex['planned_count']
                    
                    exercises_list.append(exercise_data)
                
                # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∏ –±–µ–∑ —É–ø—Ä–∞–∂–Ω–µ–Ω–∏–π (–ø–æ—Å–ª–µ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏)
                if not exercises_list:
                    continue
                
                # –ù–∞—Ö–æ–¥–∏–º –æ–±—â–µ–µ –≤—Ä–µ–º—è —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∏ (–∏—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ–ª—å–∫–æ –æ—Å—Ç–∞–≤—à–∏–µ—Å—è —É–ø—Ä–∞–∂–Ω–µ–Ω–∏—è)
                filtered_exercises = [ex for ex in exercises if not (ex['actual_duration_seconds'] is not None and ex['actual_duration_seconds'] > 1200)]
                start_times = [ex['datetime_start'] for ex in filtered_exercises if ex['datetime_start']]
                end_times = [ex['datetime_end'] for ex in filtered_exercises if ex['datetime_end'] and ex['status'] == 'ended']
                
                workout_start_time = min(start_times).isoformat() if start_times else None
                workout_end_time = max(end_times).isoformat() if end_times else None
                
                # –í—ã—á–∏—Å–ª—è–µ–º –æ–±—â—É—é –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∏
                total_duration_seconds = None
                if start_times and end_times:
                    total_duration_seconds = int((max(end_times) - min(start_times)).total_seconds())
                
                workout_data = {
                    "workout_name": workout_name,
                    "start_time": workout_start_time,
                    "end_time": workout_end_time,
                    "total_duration_seconds": total_duration_seconds,
                    "exercises": exercises_list
                }
                workouts.append(workout_data)
            
            day_data = {
                "date": date,
                "weight_kg": day_weight,
                "workouts": workouts
            }
            
            # –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –≤–Ω–µ—à–Ω–∏—Ö —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∞—Ö
            total_activity = activity_by_date.get(date, 0)
            app_workouts_count = len(workouts)
            external_workouts = total_activity - app_workouts_count
            
            if external_workouts > 0:
                day_data["external_workouts_note"] = f"–î—Ä—É–≥–∏–µ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∏, –æ—Ç–º–µ—á–µ–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º, –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω—ã–µ –Ω–µ –≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏: {external_workouts} —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∏."
            
            days.append(day_data)
        
        # –î–æ–±–∞–≤–ª—è–µ–º –¥–Ω–∏ —Ç–æ–ª—å–∫–æ —Å –≤–µ—Å–æ–º (–±–µ–∑ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–æ–∫)
        for w in weights_data:
            date_str = str(w['record_date'])
            if not any(day['date'] == date_str for day in days):
                day_data = {
                    "date": date_str,
                    "weight_kg": float(w['weight']) if isinstance(w['weight'], Decimal) else w['weight'],
                    "workouts": []
                }
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤–Ω–µ—à–Ω–∏–µ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∏ –¥–ª—è –¥–Ω–µ–π –±–µ–∑ –¥–∞–Ω–Ω—ã—Ö –≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏
                total_activity = activity_by_date.get(date_str, 0)
                if total_activity > 0:
                    day_data["external_workouts_note"] = f"–î—Ä—É–≥–∏–µ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∏, –æ—Ç–º–µ—á–µ–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º, –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω—ã–µ –Ω–µ –≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏: {total_activity} —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∏."
                
                days.append(day_data)
        
        # –î–æ–±–∞–≤–ª—è–µ–º –¥–Ω–∏ —Ç–æ–ª—å–∫–æ —Å –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å—é (–±–µ–∑ –≤–µ—Å–∞ –∏ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–æ–∫ –≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏)
        for a in activities_data:
            date_str = str(a['record_date'])
            if not any(day['date'] == date_str for day in days):
                if a['workout_count'] > 0:
                    day_data = {
                        "date": date_str,
                        "weight_kg": None,
                        "workouts": [],
                        "external_workouts_note": f"–î—Ä—É–≥–∏–µ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∏, –æ—Ç–º–µ—á–µ–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º, –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω—ã–µ –Ω–µ –≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏: {a['workout_count']} —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∏."
                    }
                    days.append(day_data)
        
        # –°–æ—Ä—Ç–∏—Ä—É–µ–º –¥–Ω–∏ –ø–æ –¥–∞—Ç–µ
        days.sort(key=lambda x: x['date'])
        
        # –°—á–∏—Ç–∞–µ–º –∞–Ω–∞–ª–∏—Ç–∏–∫—É (–∏—Å–∫–ª—é—á–∞–µ–º —É–ø—Ä–∞–∂–Ω–µ–Ω–∏—è –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å—é –±–æ–ª–µ–µ 20 –º–∏–Ω—É—Ç)
        filtered_exercise_details = [ex for ex in exercise_details if not (ex['actual_duration_seconds'] is not None and ex['actual_duration_seconds'] > 1200)]
        
        total_exercises = len(filtered_exercise_details)
        completed_exercises = len([ex for ex in filtered_exercise_details if ex['status'] == 'ended'])
        total_exercise_time_seconds = sum(ex['actual_duration_seconds'] for ex in filtered_exercise_details 
                                        if ex['actual_duration_seconds'] is not None and ex['status'] == 'ended')
        
        # –°–æ–±–∏—Ä–∞–µ–º —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ –≥—Ä—É–ø–ø—ã –º—ã—à—Ü
        muscle_groups_worked = set(ex['muscle_group_name'] for ex in filtered_exercise_details if ex['status'] == 'ended')
        
        # –§–æ—Ä–º–∏—Ä—É–µ–º –∏—Ç–æ–≥–æ–≤—É—é —É–ø—Ä–æ—â–µ–Ω–Ω—É—é —Å—Ç—Ä—É–∫—Ç—É—Ä—É
        result = {
            "user_id": user_id,
            "period_start": str(date_start),
            "period_end": str(date_ended),
            "total_days": (datetime.fromisoformat(str(date_ended)) - datetime.fromisoformat(str(date_start))).days + 1,
            "days": days,
            "summary": {
                "total_exercises": total_exercises,
                "completed_exercises": completed_exercises,
                "completion_rate_percent": round((completed_exercises / total_exercises * 100) if total_exercises > 0 else 0, 1),
                "total_exercise_time_seconds": total_exercise_time_seconds,
                "unique_workouts": len(set(ex['workout_uuid'] for ex in filtered_exercise_details if ex['workout_uuid'])),
                "muscle_groups_worked": sorted(list(muscle_groups_worked)),
                "days_with_workouts": len([day for day in days if day['workouts']]),
                "weight_records": len(weights_data)
            }
        }
        
        return result 